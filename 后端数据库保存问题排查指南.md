# 后端数据库保存问题排查指南

## 问题现象

- ✅ 前端请求成功（200 OK）
- ✅ 后端返回成功响应 `{code: 200, message: 'success', data: null}`
- ❌ 但数据库中**没有保存数据**

## 可能的原因

### 1. 后端没有真正执行数据库操作

**检查点：**
- 后端 Controller 是否调用了 Service 层的方法？
- Service 层是否调用了 DAO/Repository 的方法？
- 是否有事务管理，但事务被回滚了？

**示例问题代码：**
```java
// ❌ 错误：只返回成功，但没有保存
@PostMapping("/questionnaire")
public Result submitQuestionnaire(@RequestBody QuestionnaireDTO dto) {
    // 缺少实际的保存操作
    return Result.success(); // 只返回成功，但没有保存数据
}

// ✅ 正确：应该调用保存方法
@PostMapping("/questionnaire")
public Result submitQuestionnaire(@RequestBody QuestionnaireDTO dto) {
    questionnaireService.saveQuestionnaire(dto);
    return Result.success();
}
```

### 2. 数据库事务未提交

**检查点：**
- 是否使用了 `@Transactional` 注解？
- 事务是否被回滚了（检查异常日志）？
- 数据库连接是否正确？

**示例问题代码：**
```java
// ❌ 错误：事务被回滚
@Transactional
public void saveQuestionnaire(QuestionnaireDTO dto) {
    // 某些操作失败，导致事务回滚
    // 但没有抛出异常，所以前端看到的是成功
}

// ✅ 正确：确保事务提交
@Transactional(rollbackFor = Exception.class)
public void saveQuestionnaire(QuestionnaireDTO dto) {
    try {
        // 保存操作
        questionnaireRepository.save(dto);
    } catch (Exception e) {
        // 记录日志并抛出异常
        log.error("保存问卷失败", e);
        throw e;
    }
}
```

### 3. 数据格式不匹配导致保存失败

**检查点：**
- 后端接收的数据格式是否与前端发送的一致？
- 字段映射是否正确（如 `interests` 数组、`ageRequirement` 对象）？
- 是否有必填字段缺失？

**前端发送的数据格式：**
```json
{
  "userId": 18,
  "interests": ["reading"],
  "socialEnergy": "ambivert",
  "decisionMaking": "...",
  "ageRequirement": {
    "unlimited": false,
    "minAge": 18,
    "maxAge": 30
  },
  "relationshipQualities": [],
  "mustHaveQualities": [],
  "priorityQualities": []
}
```

**后端需要处理：**
- `interests` 是数组，需要保存到 `user_hobby` 表（多对多关系）
- `ageRequirement` 是对象，需要拆分为 `ageMin`, `ageMax`, `ageUnlimited` 字段
- `relationshipQualities` 是数组，需要保存到 `user_relationship_quality` 表

### 4. 数据库表结构问题

**检查点：**
- 数据库表是否存在？
- 表结构是否与代码中的实体类匹配？
- 外键约束是否正确？

**建议的表结构：**
```sql
-- 主表：用户问卷基本信息
CREATE TABLE user_questionnaire (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  user_id BIGINT NOT NULL,
  social_energy VARCHAR(50),
  decision_making VARCHAR(50),
  life_rhythm VARCHAR(50),
  communication_style VARCHAR(50),
  preferred_social_style VARCHAR(50),
  preferred_lifestyle VARCHAR(50),
  preferred_interests VARCHAR(50),
  preferred_relationship_mode VARCHAR(50),
  communication_expectation VARCHAR(50),
  age_min INT,
  age_max INT,
  age_unlimited BOOLEAN DEFAULT FALSE,
  distance_requirement VARCHAR(50),
  additional_requirements TEXT,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  UNIQUE KEY uk_user_id (user_id),
  FOREIGN KEY (user_id) REFERENCES users(id)
);

-- 用户爱好表（多对多）
CREATE TABLE user_hobby (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  user_id BIGINT NOT NULL,
  hobby VARCHAR(50) NOT NULL,
  FOREIGN KEY (user_id) REFERENCES users(id),
  UNIQUE KEY uk_user_hobby (user_id, hobby)
);

-- 用户关系品质表（多对多）
CREATE TABLE user_relationship_quality (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  user_id BIGINT NOT NULL,
  quality VARCHAR(50) NOT NULL,
  FOREIGN KEY (user_id) REFERENCES users(id),
  UNIQUE KEY uk_user_quality (user_id, quality)
);

-- 必须维度表（多对多）
CREATE TABLE user_matching_must_dimension (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  user_id BIGINT NOT NULL,
  dimension VARCHAR(50) NOT NULL,
  FOREIGN KEY (user_id) REFERENCES users(id),
  UNIQUE KEY uk_user_dimension (user_id, dimension)
);

-- 优先维度表（多对多）
CREATE TABLE user_matching_priority_dimension (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  user_id BIGINT NOT NULL,
  dimension VARCHAR(50) NOT NULL,
  FOREIGN KEY (user_id) REFERENCES users(id),
  UNIQUE KEY uk_user_priority (user_id, dimension)
);
```

### 5. 后端日志没有记录错误

**检查点：**
- 后端是否有异常捕获，但被静默处理了？
- 日志级别是否设置正确？
- 是否有 try-catch 吞掉了异常？

**建议的后端代码：**
```java
@PostMapping("/questionnaire")
public Result submitQuestionnaire(@RequestBody QuestionnaireDTO dto) {
    try {
        log.info("收到问卷提交请求，userId: {}, 数据: {}", dto.getUserId(), dto);
        
        // 验证数据
        if (dto.getUserId() == null) {
            return Result.error("用户ID不能为空");
        }
        
        // 保存数据
        questionnaireService.saveQuestionnaire(dto);
        
        log.info("问卷保存成功，userId: {}", dto.getUserId());
        return Result.success("问卷提交成功");
        
    } catch (Exception e) {
        log.error("问卷保存失败，userId: " + dto.getUserId(), e);
        return Result.error("问卷保存失败: " + e.getMessage());
    }
}
```

## 排查步骤

### 步骤1：检查后端日志

查看后端控制台或日志文件，查找：
- 是否有异常信息？
- 是否有 SQL 执行日志？
- 是否有事务回滚信息？

### 步骤2：检查数据库

直接查询数据库，确认数据是否保存：

```sql
-- 检查用户问卷主表
SELECT * FROM user_questionnaire WHERE user_id = 18;

-- 检查用户爱好
SELECT * FROM user_hobby WHERE user_id = 18;

-- 检查关系品质
SELECT * FROM user_relationship_quality WHERE user_id = 18;

-- 检查必须维度
SELECT * FROM user_matching_must_dimension WHERE user_id = 18;

-- 检查优先维度
SELECT * FROM user_matching_priority_dimension WHERE user_id = 18;
```

### 步骤3：检查后端代码

1. **检查 Controller 层**
   - 是否接收到了请求？
   - 是否调用了 Service 层？

2. **检查 Service 层**
   - 是否调用了 Repository/DAO 层？
   - 是否有事务管理？
   - 是否有异常处理？

3. **检查 Repository/DAO 层**
   - SQL 语句是否正确？
   - 参数绑定是否正确？
   - 是否使用了正确的表名和字段名？

### 步骤4：添加调试日志

在后端关键位置添加日志：

```java
@PostMapping("/questionnaire")
public Result submitQuestionnaire(@RequestBody QuestionnaireDTO dto) {
    log.info("=== 问卷提交开始 ===");
    log.info("接收到的数据: {}", JSON.toJSONString(dto));
    
    try {
        questionnaireService.saveQuestionnaire(dto);
        log.info("=== 问卷保存成功 ===");
        return Result.success();
    } catch (Exception e) {
        log.error("=== 问卷保存失败 ===", e);
        return Result.error(e.getMessage());
    }
}
```

## 常见错误示例

### 错误1：只保存了主表，没有保存关联表

```java
// ❌ 错误：只保存了主表
public void saveQuestionnaire(QuestionnaireDTO dto) {
    UserQuestionnaire entity = convertToEntity(dto);
    questionnaireRepository.save(entity);
    // 缺少保存 interests、relationshipQualities 等关联数据
}

// ✅ 正确：保存所有相关数据
public void saveQuestionnaire(QuestionnaireDTO dto) {
    // 保存主表
    UserQuestionnaire entity = convertToEntity(dto);
    questionnaireRepository.save(entity);
    
    // 保存爱好（先删除旧的，再保存新的）
    hobbyRepository.deleteByUserId(dto.getUserId());
    for (String hobby : dto.getInterests()) {
        hobbyRepository.save(new UserHobby(dto.getUserId(), hobby));
    }
    
    // 保存关系品质
    qualityRepository.deleteByUserId(dto.getUserId());
    for (String quality : dto.getRelationshipQualities()) {
        qualityRepository.save(new UserRelationshipQuality(dto.getUserId(), quality));
    }
    
    // ... 其他关联数据
}
```

### 错误2：事务被回滚但没有抛出异常

```java
// ❌ 错误：异常被捕获但没有抛出
@Transactional
public void saveQuestionnaire(QuestionnaireDTO dto) {
    try {
        questionnaireRepository.save(dto);
        // 如果这里出错，事务会回滚，但异常被吞掉了
    } catch (Exception e) {
        log.error("保存失败", e);
        // 没有重新抛出异常，所以前端看到的是成功
    }
}

// ✅ 正确：抛出异常让事务回滚
@Transactional(rollbackFor = Exception.class)
public void saveQuestionnaire(QuestionnaireDTO dto) {
    questionnaireRepository.save(dto);
    // 如果出错，异常会自动抛出，事务会回滚
}
```

## 建议的修复方案

1. **在后端添加详细的日志**
   - 记录接收到的数据
   - 记录每个保存步骤
   - 记录异常信息

2. **检查数据库操作**
   - 确认所有表都存在
   - 确认外键约束正确
   - 确认字段类型匹配

3. **添加数据验证**
   - 验证必填字段
   - 验证数据格式
   - 验证关联数据

4. **返回保存的数据**
   - 保存成功后，返回保存的数据（而不是 null）
   - 这样前端可以确认数据确实保存了

## 前端可以做的检查

在浏览器控制台查看：

1. **Network 标签**
   - 查看请求的完整 URL
   - 查看请求体（Payload）
   - 查看响应内容

2. **Console 标签**
   - 查看前端打印的完整数据
   - 确认所有字段都有值

3. **Application 标签**
   - 检查 localStorage 中的 token
   - 确认用户已登录

